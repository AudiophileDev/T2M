package com.audiophile.t2m.text;import com.audiophile.t2m.reader.CSVReader;import javafx.util.Pair;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class WordsDB {    /**     * Global database which holds words with their tendency and effects     */    private static Map<String, WordAttributes> database;    /**     * Loads word database from CSV file.     *     * @param file CSV file     * @throws IOException Throws exception if file could not be read of has wrong format     * @see com.audiophile.t2m.reader.CSVReader#ReadFile(String)     */    public static void loadDB(String file) throws IOException {        String[][] table = CSVReader.ReadFile(file);        if (table[0].length < 3)            throw new IOException("Word database file \"" + file + "\" does not provide word,tendency and effect column");        //TODO maybe replace HashMap with Trie (test efficiency first!)        database = new HashMap<>(table.length);        for (String[] row : table) {            database.put(row[0], new WordAttributes(WordTendency.map(row[1]), row[2].isEmpty() ? null : row[2]));        }    }    /**     * Calculates the similarity (a number within 0 and 1) between two strings.     *     * @param s1 first string     * @param s2 second string     * @return Value between 0.0 and 1.0 (1 if strings are equal)     */    private static double similarity(String s1, String s2) {        String longer = s1, shorter = s2;        if (s1.length() < s2.length()) { // longer should always have greater length            longer = s2;            shorter = s1;        }        int longerLength = longer.length();        if (longerLength == 0) {            return 1.0; /* both strings are zero length */        }        return (longerLength - editDistance(longer, shorter)) / (double) longerLength;    }    // Example implementation of the Levenshtein Edit Distance    // See http://rosettacode.org/wiki/Levenshtein_distance#Java    private    static int editDistance(String s1, String s2) {        s1 = s1.toLowerCase();        s2 = s2.toLowerCase();        int[] costs = new int[s2.length() + 1];        for (int i = 0; i <= s1.length(); i++) {            int lastValue = i;            for (int j = 0; j <= s2.length(); j++) {                if (i == 0)                    costs[j] = j;                else {                    if (j > 0) {                        int newValue = costs[j - 1];                        if (s1.charAt(i - 1) != s2.charAt(j - 1))                            newValue = Math.min(Math.min(newValue, lastValue),                                    costs[j]) + 1;                        costs[j - 1] = lastValue;                        lastValue = newValue;                    }                }            }            if (i > 0)                costs[s2.length()] = lastValue;        }        return costs[s2.length()];    }    /**     * The minimum similarity needed to see two words as similar     *     * @see #GetWordAttribute(String)     */    private static final double MIN_SIMILARITY = 0.65;//TODO find best value    /**     * Function searches for closest word in database and returns its <code>WordAttributes</code>     * if se similarity if bigger than {@value #MIN_SIMILARITY}     *     * @param word The word to find the attributes for     * @return The <code>WordAttributes</code> or null if it was not found in the database     * @throws IOException Throws exception if database was not loaded jet     */    public static Pair<String, WordAttributes> GetWordAttribute(String word) throws IOException {        if (database == null)            throw new IOException("Word database was not loaded jet");        String key = null;        double maxSimilarity = 0;        for (String k : database.keySet()) {            double similarity = similarity(word, k);            if (similarity > MIN_SIMILARITY && similarity > maxSimilarity) {                key = k;                maxSimilarity = similarity;                //System.out.println(String.format("%.3f is the similarity between \"%s\" and \"%s\"", similarity, word, k));            }        }        return key != null ? new Pair<>(key, database.getOrDefault(key, null)) : null;    }    /**     * Class for key attribute mapping     */    public static class WordAttributes {        public WordTendency tendency;        public String effect;        public WordAttributes(WordTendency tendency, String effect) {            this.tendency = tendency;            this.effect = effect;        }    }    /**     * Class for the representation of a words tendency.     * <ul>     * <li>Bad = 0</li>     * <li>Negative = 1</li>     * <li>Neutral = 2</li>     * <li>Positive = 3</li>     * <li>Good = 4</li>     * </ul>     */    public enum WordTendency {        Bad(0), Negative(1), Neutral(2), Positive(3), Good(4);        final int value;        WordTendency(int value) {            this.value = value;        }        /**         * Converts a string of a number to a <code>WordTendency</code>         *         * @param text number as string         * @return corresponding <code>WordTendency</code> with Neutral(2) as default         */        public static WordTendency map(String text) {            int v;            try {                v = Integer.parseInt(text);            } catch (NumberFormatException nfe) {                v = 2;            }            switch (v) {                case 0:                    return Bad;                case 1:                    return Negative;                case 3:                    return Positive;                case 4:                    return Good;                default:                    return Neutral;            }        }    }}