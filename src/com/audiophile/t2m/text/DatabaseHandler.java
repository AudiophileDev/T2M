package com.audiophile.t2m.text;import com.audiophile.t2m.reader.CSVTools;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class DatabaseHandler {    /**     * The minimum similarity needed to see two words as similar     *     * @see #FindWord(String, double)     */    public static double DEFAULT_IN_SIMILARITY = 0.65;//TODO find best value    /**     * Global database which holds words with their tendency and effects     */    private static Map<String, Entry> database;    private static String file;    /**     * Loads word database from CSV file.     *     * @param file CSV file     * @throws IOException Throws exception if file could not be read of has wrong format     * @see CSVTools#ReadFile(String)     */    public static void LoadDB(String file) throws IOException {        DatabaseHandler.file = file;        String[][] table = CSVTools.ReadFile(file);        if (table.length > 0 && table[0].length < 3)            throw new IOException("Word database file \"" + file + "\" does not provide word,tendency and effect column");        //TODO maybe replace HashMap with Trie (test efficiency first!)        database = new HashMap<>(table.length);        for (String[] row : table) {            assert row[0] != null;            database.put(row[0], new Entry(row[0], Word.Tendency.map(row[1]), (row[2].isEmpty() ? null : row[2])));        }    }    //TODO doc    public static void SetWord(Word word) throws IOException {        database.put(word.getName(), word.getEntry());        writeDatabase();    }    public static void RemoveWord(String word) throws IOException {        database.remove(word);        writeDatabase();    }    private static void writeDatabase() throws IOException {        String[][] db = new String[database.size()][3];        final int[] i = {0};        database.forEach((k, v) ->                db[i[0]++] = new String[]{k, String.valueOf(v.getTendency().value), v.getEffect()}        );        CSVTools.WriteFile(file, db);    }    /**     * Calculates the similarity (a number within 0 and 1) between two strings.     *     * @param s1 first string     * @param s2 second string     * @return Value between 0.0 and 1.0 (1 if strings are equal)     */    private static double similarity(String s1, String s2) {        String longer = s1, shorter = s2;        if (s1.length() < s2.length()) { // longer should always have greater length            longer = s2;            shorter = s1;        }        int longerLength = longer.length();        if (longerLength == 0) {            return 1.0; /* both strings are zero length */        }        return (longerLength - editDistance(longer, shorter)) / (double) longerLength;    }    // Example implementation of the Levenshtein Edit Distance    // See http://rosettacode.org/wiki/Levenshtein_distance#Java    private static int editDistance(String s1, String s2) {        s1 = s1.toLowerCase();        s2 = s2.toLowerCase();        int[] costs = new int[s2.length() + 1];        for (int i = 0; i <= s1.length(); i++) {            int lastValue = i;            for (int j = 0; j <= s2.length(); j++) {                if (i == 0)                    costs[j] = j;                else {                    if (j > 0) {                        int newValue = costs[j - 1];                        if (s1.charAt(i - 1) != s2.charAt(j - 1))                            newValue = Math.min(Math.min(newValue, lastValue),                                    costs[j]) + 1;                        costs[j - 1] = lastValue;                        lastValue = newValue;                    }                }            }            if (i > 0)                costs[s2.length()] = lastValue;        }        return costs[s2.length()];    }    /**     * Represents an entry in the database     */    public static class Entry {        private Word.Tendency tendency;        private String name, effect;        public Entry(String name, Word.Tendency tendency, String effect) {            this.tendency = tendency;            this.effect = effect;            this.name = name;        }        public Word.Tendency getTendency() {            return tendency;        }        public String getEffect() {            return effect;        }        public String getName() {            return name;        }    }    /**     * Function searches for closest word in database and returns its <code>WordAttributes</code>     * if se similarity if bigger than {@value #DEFAULT_IN_SIMILARITY}     *     * @param word The word to find the attributes for     * @return The <code>WordAttributes</code> or null if it was not found in the database     * @throws IOException Throws exception if database was not loaded jet     */    public static Entry FindWord(String word, double minSimilarity) throws IOException {        if (database == null)            throw new IOException("Word database was not loaded jet");        Entry entry = null;        double maxSimilarity = 0;        for (String k : database.keySet()) {            double similarity = similarity(word, k);            if (similarity > minSimilarity && similarity > maxSimilarity) {                entry = database.get(k);                maxSimilarity = similarity;            }        }        return entry;    }}